'use strict';

exports.__esModule = true;
exports.default = tokenize;

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var openParen = 40;
var closeParen = 41;
var singleQuote = 39;
var doubleQuote = 34;
var backslash = 92;
var slash = 47;
var comma = 44;
var colon = 58;
var asterisk = 42;
var minus = 45;
var plus = 43;
var newline = 10;
var space = 32;
var feed = 12;
var tab = 9;
var cr = 13;
var at = 64;
var atEnd = /[ \n\t\r\{\(\)'"\\;,/]/g;
var wordEnd = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
var wordEndNum = /[ \n\t\r\(\)\*:;@!&'"\-\+\|~>,\[\]\\]|\//g;

function tokenize(input) {
  var tokens = [];
  var css = input.valueOf();

  var code = void 0,
      next = void 0,
      quote = void 0,
      lines = void 0,
      last = void 0,
      content = void 0,
      escape = void 0,
      nextLine = void 0,
      nextOffset = void 0,
      escaped = void 0,
      escapePos = void 0,
      nextChar = void 0;

  var length = css.length;
  var offset = -1;
  var line = 1;
  var pos = 0;

  var unclosed = function unclosed(what) {
    var message = _util2.default.format('Unclosed %s at line: %d, column: %d, token: %d', what, line, pos - offset, pos);
    throw new Error(message);
  };

  while (pos < length) {
    code = css.charCodeAt(pos);

    if (code === newline) {
      offset = pos;
      line += 1;
    }

    switch (code) {
      case newline:
      case space:
      case tab:
      case cr:
      case feed:
        next = pos;
        do {
          next += 1;
          code = css.charCodeAt(next);
          if (code === newline) {
            offset = next;
            line += 1;
          }
        } while (code === space || code === newline || code === tab || code === cr || code === feed);

        tokens.push(['space', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);

        pos = next - 1;
        break;

      case colon:
        next = pos + 1;
        tokens.push(['colon', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);

        pos = next - 1;
        break;

      case comma:
        next = pos + 1;
        tokens.push(['comma', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);

        pos = next - 1;
        break;

      case openParen:
        tokens.push(['(', '(', line, pos - offset, line, next - offset, pos]);
        break;

      case closeParen:
        tokens.push([')', ')', line, pos - offset, line, next - offset, pos]);
        break;

      case singleQuote:
      case doubleQuote:
        quote = code === singleQuote ? '\'' : '"';
        next = pos;
        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);
          if (next === -1) {
            unclosed('quote', quote);
          }
          escapePos = next;
          while (css.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);
        pos = next;
        break;

      case at:
        atEnd.lastIndex = pos + 1;
        atEnd.test(css);

        if (atEnd.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = atEnd.lastIndex - 2;
        }

        tokens.push(['atword', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);
        pos = next;
        break;

      case backslash:
        next = pos;
        code = css.charCodeAt(next + 1);

        if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {
          next += 1;
        }

        tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);

        pos = next;
        break;

      case plus:
      case minus:
      case asterisk:
        next = pos + 1;
        nextChar = css.slice(pos + 1, next + 1);

        // if the operator is immediately followed by a word character, then we
        // have a prefix of some kind, and should fall-through. eg. -webkit

        /* eslint no-fallthrough: 0 */
        if (!/[a-z]/gi.test(nextChar)) {

          tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);

          pos = next - 1;
          break;
        }

      // NOTE: This is the only case that should fall-through. If we run into
      // another situation where we need fall-through, then we need to break
      // this select out into functions.

      default:
        if (code === slash && css.charCodeAt(pos + 1) === asterisk) {
          next = css.indexOf('*/', pos + 2) + 1;
          if (next === 0) {
            unclosed('comment', '*/');
          }

          content = css.slice(pos, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset, pos]);

          offset = nextOffset;
          line = nextLine;
          pos = next;
        }
        // catch a regular slash, that isn't a comment
        else if (code === slash) {
            next = pos + 1;

            tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);

            pos = next - 1;
          } else {
            var regex = wordEnd;

            // we're dealing with a word that starts with a number
            // those get treated differently
            if (code >= 48 && code <= 57) {
              regex = wordEndNum;
            }

            regex.lastIndex = pos + 1;
            regex.test(css);

            if (regex.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = regex.lastIndex - 2;
            }

            tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);
            pos = next;
          }
        break;
    }

    pos++;
  }

  return tokens;
}
module.exports = exports['default'];