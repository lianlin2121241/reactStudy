'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _root = require('./root');

var _root2 = _interopRequireDefault(_root);

var _value = require('./value');

var _value2 = _interopRequireDefault(_value);

var _atword = require('./atword');

var _atword2 = _interopRequireDefault(_atword);

var _colon = require('./colon');

var _colon2 = _interopRequireDefault(_colon);

var _comma = require('./comma');

var _comma2 = _interopRequireDefault(_comma);

var _comment = require('./comment');

var _comment2 = _interopRequireDefault(_comment);

var _function = require('./function');

var _function2 = _interopRequireDefault(_function);

var _number = require('./number');

var _number2 = _interopRequireDefault(_number);

var _operator = require('./operator');

var _operator2 = _interopRequireDefault(_operator);

var _paren = require('./paren');

var _paren2 = _interopRequireDefault(_paren);

var _string = require('./string');

var _string2 = _interopRequireDefault(_string);

var _word = require('./word');

var _word2 = _interopRequireDefault(_word);

var _tokenize = require('./tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _flatten = require('flatten');

var _flatten2 = _interopRequireDefault(_flatten);

var _indexesOf = require('indexes-of');

var _indexesOf2 = _interopRequireDefault(_indexesOf);

var _uniq = require('uniq');

var _uniq2 = _interopRequireDefault(_uniq);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function sortAscending(list) {
  return list.sort(function (a, b) {
    return a - b;
  });
}

var Parser = function () {
  function Parser(input) {
    _classCallCheck(this, Parser);

    this.input = input;
    this.position = 0;
    // we'll use this to keep track of the paren balance
    this.unbalanced = 0;
    this.root = new _root2.default();

    var value = new _value2.default();
    this.root.append(value);

    this.current = value;
    this.tokens = (0, _tokenize2.default)(input);
  }

  Parser.prototype.parse = function parse() {
    return this.loop();
  };

  Parser.prototype.colon = function colon() {
    var token = this.currToken;

    this.newNode(new _colon2.default({
      value: token[1],
      source: {
        start: {
          line: token[2],
          column: token[3]
        },
        end: {
          line: token[4],
          column: token[5]
        }
      },
      sourceIndex: token[6]
    }));

    this.position++;
  };

  Parser.prototype.comma = function comma() {
    var token = this.currToken;

    this.newNode(new _comma2.default({
      value: token[1],
      source: {
        start: {
          line: token[2],
          column: token[3]
        },
        end: {
          line: token[4],
          column: token[5]
        }
      },
      sourceIndex: token[6]
    }));

    this.position++;
  };

  Parser.prototype.comment = function comment() {
    var node = new _comment2.default({
      value: this.currToken[1].replace(/\/\*|\*\//g, ''),
      source: {
        start: {
          line: this.currToken[2],
          column: this.currToken[3]
        },
        end: {
          line: this.currToken[4],
          column: this.currToken[5]
        }
      },
      sourceIndex: this.currToken[6]
    });

    this.newNode(node);
    this.position++;
  };

  Parser.prototype.error = function error(message) {
    throw new Error(message); // eslint-disable-line new-cap
  };

  Parser.prototype.loop = function loop() {
    while (this.position < this.tokens.length) {
      this.parseTokens();
    }

    if (!this.current.last && this.spaces) {
      this.current.raws.before += this.spaces;
    } else if (this.spaces) {
      this.current.last.raws.after += this.spaces;
    }

    this.spaces = '';

    return this.root;
  };

  Parser.prototype.operator = function operator() {

    var node = new _operator2.default({
      value: this.currToken[1],
      source: {
        start: {
          line: this.currToken[2],
          column: this.currToken[3]
        },
        end: {
          line: this.currToken[2],
          column: this.currToken[3]
        }
      },
      sourceIndex: this.currToken[4]
    });

    this.position++;

    return this.newNode(node);
  };

  Parser.prototype.parseTokens = function parseTokens() {
    switch (this.currToken[0]) {
      case 'space':
        this.space();
        break;
      case 'colon':
        this.colon();
        break;
      case 'comma':
        this.comma();
        break;
      case 'comment':
        this.comment();
        break;
      case '(':
        this.parenOpen();
        break;
      case ')':
        this.parenClose();
        break;
      case 'atword':
      case 'word':
        this.word();
        break;
      case 'operator':
        this.operator();
        break;
      case 'string':
        this.string();
        break;
      default:
        this.word();
        break;
    }
  };

  Parser.prototype.parenOpen = function parenOpen() {
    var unbalanced = 1;
    var pos = this.position + 1;
    var token = this.currToken;

    // check for balanced parens
    while (pos < this.tokens.length && unbalanced) {
      var tkn = this.tokens[pos];

      if (tkn[0] === '(') {
        unbalanced++;
      }
      if (tkn[0] === ')') {
        unbalanced--;
      }
      pos++;
    }

    if (unbalanced) {
      this.error('Expected closing parenthesis.');
    }

    // ok, all parens are balanced. continue on

    var last = this.current.last;

    if (last && last.type === 'func' && last.unbalanced < 0) {
      last.unbalanced = 0; // ok we're ready to add parens now
      this.cache = this.current;
      this.current = last;
    }

    this.current.unbalanced++;

    this.newNode(new _paren2.default({
      value: token[1],
      source: {
        start: {
          line: token[2],
          column: token[3]
        },
        end: {
          line: token[4],
          column: token[5]
        }
      },
      sourceIndex: token[6]
    }));

    this.position++;

    // url functions get special treatment, and anything between the function
    // parens get treated as one word, if the contents aren't not a string.
    if (this.current.type === 'func' && this.current.unbalanced && this.current.value === 'url' && this.currToken[0] !== 'string') {
      var nextToken = this.nextToken;
      var value = this.currToken[1];
      var start = {
        line: this.currToken[2],
        column: this.currToken[3]
      };

      while (nextToken && nextToken[0] !== ')' && this.current.unbalanced) {
        this.position++;
        value += this.currToken[1];
        nextToken = this.nextToken;
      }

      if (this.position !== this.tokens.length - 1) {
        // skip the following word definition, or it'll be a duplicate
        this.position++;

        this.newNode(new _word2.default({
          value: value,
          source: {
            start: start,
            end: {
              line: this.currToken[4],
              column: this.currToken[5]
            }
          },
          sourceIndex: this.currToken[6]
        }));
      }
    }
  };

  Parser.prototype.parenClose = function parenClose() {
    var token = this.currToken;

    this.newNode(new _paren2.default({
      value: token[1],
      source: {
        start: {
          line: token[2],
          column: token[3]
        },
        end: {
          line: token[4],
          column: token[5]
        }
      },
      sourceIndex: token[6]
    }));

    this.position++;

    if (this.position > this.tokens.length - 1) {
      return;
    }

    this.current.unbalanced--;

    if (this.current.unbalanced < 0) {
      this.error('Expected opening parenthesis.');
    }

    if (!this.current.unbalanced && this.cache) {
      this.current = this.cache;
      this.cache = null;
    }
  };

  Parser.prototype.space = function space() {
    var token = this.currToken;
    // Handle space before and after the selector
    if (this.position === this.tokens.length - 1 || this.nextToken[0] === ',' || this.nextToken[0] === ')') {
      this.current.last.raws.after += token[1];
      this.position++;
    } else {
      this.spaces = token[1];
      this.position++;
    }
  };

  Parser.prototype.splitWord = function splitWord() {
    var _this = this;

    var nextToken = this.nextToken;
    var word = this.currToken[1];

    while (nextToken && nextToken[0] === 'word') {
      this.position++;

      var current = this.currToken[1];
      word += current;

      nextToken = this.nextToken;
    }

    var hasAt = (0, _indexesOf2.default)(word, '@');
    var indices = sortAscending((0, _uniq2.default)((0, _flatten2.default)([[0], hasAt])));
    var rNumber = /^((\d+(\.\d*)?)|(\.\d+))/;

    indices.forEach(function (ind, i) {
      var index = indices[i + 1] || word.length;
      var value = word.slice(ind, index);
      var node = void 0;

      if (~hasAt.indexOf(ind)) {
        node = new _atword2.default({
          value: value.slice(1),
          source: {
            start: {
              line: _this.currToken[2],
              column: _this.currToken[3] + ind
            },
            end: {
              line: _this.currToken[4],
              column: _this.currToken[3] + (index - 1)
            }
          },
          sourceIndex: _this.currToken[6] + indices[i]
        });
      } else if (rNumber.test(_this.currToken[1])) {
        var unit = value.replace(rNumber, '');

        node = new _number2.default({
          value: value.replace(unit, ''),
          source: {
            start: {
              line: _this.currToken[2],
              column: _this.currToken[3] + ind
            },
            end: {
              line: _this.currToken[4],
              column: _this.currToken[3] + (index - 1)
            }
          },
          sourceIndex: _this.currToken[6] + indices[i],
          unit: unit
        });
      } else {
        node = new (nextToken && nextToken[0] === '(' ? _function2.default : _word2.default)({
          value: value,
          source: {
            start: {
              line: _this.currToken[2],
              column: _this.currToken[3] + ind
            },
            end: {
              line: _this.currToken[4],
              column: _this.currToken[3] + (index - 1)
            }
          },
          sourceIndex: _this.currToken[6] + indices[i]
        });

        if (node.constructor.name === 'Word') {
          node.isHex = /^#/.test(value);
          node.isColor = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(value);
        }
      }

      _this.newNode(node);
    });

    this.position++;
  };

  Parser.prototype.string = function string() {
    var token = this.currToken;
    var value = this.currToken[1];
    var rQuote = /^(\"|\')/;
    var quoted = rQuote.test(value);
    var quote = '';
    var node = void 0;

    if (quoted) {
      quote = value.match(rQuote)[0];
      // set value to the string within the quotes
      // quotes are stored in raws
      value = value.slice(1, value.length - 1);
    }

    node = new _string2.default({
      value: value,
      source: {
        start: {
          line: token[2],
          column: token[3]
        },
        end: {
          line: token[4],
          column: token[5]
        }
      },
      sourceIndex: token[6],
      quoted: quoted
    });

    node.raws.quote = quote;

    this.newNode(node);
    this.position++;
  };

  Parser.prototype.word = function word() {
    return this.splitWord();
  };

  Parser.prototype.missingParenthesis = function missingParenthesis() {
    return this.error('Expected opening parenthesis.');
  };

  Parser.prototype.newNode = function newNode(node) {
    if (this.spaces) {
      node.raws.before += this.spaces;
      this.spaces = '';
    }

    return this.current.append(node);
  };

  _createClass(Parser, [{
    key: 'currToken',
    get: function get() {
      return this.tokens[this.position];
    }
  }, {
    key: 'nextToken',
    get: function get() {
      return this.tokens[this.position + 1];
    }
  }, {
    key: 'prevToken',
    get: function get() {
      return this.tokens[this.position - 1];
    }
  }]);

  return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];