'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.check = undefined;

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 当前文件所代表的规则名称
 *
 * @const
 * @type {string}
 */
/**
 * @file font-sizes 的检测逻辑
 *       Too many font-size declarations, abstraction needed
 *       https://github.com/CSSLint/csslint/wiki/Don't-use-too-many-font-size-declarations
 * @author ielgnaw(wuji0223@gmail.com)
 */

var RULENAME = 'font-sizes';

/**
 * 错误的信息
 *
 * @const
 * @type {string}
 */
var MSG = '`font-size` must not be greater than ';

var fontSizeCount = 0;

/**
 * 具体的检测逻辑
 *
 * @param {Object} opts 参数
 * @param {*} opts.ruleVal 当前规则具体配置的值
 * @param {string} opts.fileContent 文件内容
 * @param {string} opts.filePath 文件路径
 */
var check = exports.check = _postcss2.default.plugin(RULENAME, function (opts) {
    return function (css, result) {
        if (!opts.ruleVal || isNaN(opts.ruleVal)) {
            return;
        }

        fontSizeCount = 0;

        css.walkDecls(function (decl) {
            if (global.CSSHINT_INVALID_ALL_COUNT >= opts.maxError) {
                return;
            }

            var prop = decl.prop;
            if (prop === 'font-size') {
                fontSizeCount++;
            }
        });

        if (fontSizeCount > opts.ruleVal) {
            var str = MSG + opts.ruleVal + ', current file `font-size` is ' + fontSizeCount;
            result.warn(RULENAME, {
                node: css,
                ruleName: RULENAME,
                message: str,
                colorMessage: _chalk2.default.grey(str)
            });

            global.CSSHINT_INVALID_ALL_COUNT++;
        }
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlL2ZvbnQtc2l6ZXMuanMiXSwibmFtZXMiOlsiUlVMRU5BTUUiLCJNU0ciLCJmb250U2l6ZUNvdW50IiwiY2hlY2siLCJwbHVnaW4iLCJjc3MiLCJyZXN1bHQiLCJvcHRzIiwicnVsZVZhbCIsImlzTmFOIiwid2Fsa0RlY2xzIiwiZ2xvYmFsIiwiQ1NTSElOVF9JTlZBTElEX0FMTF9DT1VOVCIsIm1heEVycm9yIiwicHJvcCIsImRlY2wiLCJzdHIiLCJ3YXJuIiwibm9kZSIsInJ1bGVOYW1lIiwibWVzc2FnZSIsImNvbG9yTWVzc2FnZSIsImdyZXkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFPQTs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7O0FBVkE7Ozs7Ozs7QUFnQkEsSUFBTUEsV0FBVyxZQUFqQjs7QUFFQTs7Ozs7O0FBTUEsSUFBTUMsTUFBTSx1Q0FBWjs7QUFFQSxJQUFJQyxnQkFBZ0IsQ0FBcEI7O0FBRUE7Ozs7Ozs7O0FBUU8sSUFBTUMsd0JBQVEsa0JBQVFDLE1BQVIsQ0FBZUosUUFBZixFQUF5QjtBQUFBLFdBQzFDLFVBQUNLLEdBQUQsRUFBTUMsTUFBTixFQUFpQjtBQUNiLFlBQUksQ0FBQ0MsS0FBS0MsT0FBTixJQUFpQkMsTUFBTUYsS0FBS0MsT0FBWCxDQUFyQixFQUEwQztBQUN0QztBQUNIOztBQUVETix3QkFBZ0IsQ0FBaEI7O0FBRUFHLFlBQUlLLFNBQUosQ0FBYyxnQkFBUTtBQUNsQixnQkFBSUMsT0FBT0MseUJBQVAsSUFBb0NMLEtBQUtNLFFBQTdDLEVBQXVEO0FBQ25EO0FBQ0g7O0FBRUQsZ0JBQU1DLE9BQU9DLEtBQUtELElBQWxCO0FBQ0EsZ0JBQUlBLFNBQVMsV0FBYixFQUEwQjtBQUN0Qlo7QUFDSDtBQUNKLFNBVEQ7O0FBV0EsWUFBSUEsZ0JBQWdCSyxLQUFLQyxPQUF6QixFQUFrQztBQUM5QixnQkFBTVEsTUFBTWYsTUFBTU0sS0FBS0MsT0FBWCxHQUFxQixnQ0FBckIsR0FBd0ROLGFBQXBFO0FBQ0FJLG1CQUFPVyxJQUFQLENBQVlqQixRQUFaLEVBQXNCO0FBQ2xCa0Isc0JBQU1iLEdBRFk7QUFFbEJjLDBCQUFVbkIsUUFGUTtBQUdsQm9CLHlCQUFTSixHQUhTO0FBSWxCSyw4QkFBYyxnQkFBTUMsSUFBTixDQUFXTixHQUFYO0FBSkksYUFBdEI7O0FBT0FMLG1CQUFPQyx5QkFBUDtBQUNIO0FBQ0osS0E5QnlDO0FBQUEsQ0FBekIsQ0FBZCIsImZpbGUiOiJmb250LXNpemVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBmb250LXNpemVzIOeahOajgOa1i+mAu+i+kVxuICogICAgICAgVG9vIG1hbnkgZm9udC1zaXplIGRlY2xhcmF0aW9ucywgYWJzdHJhY3Rpb24gbmVlZGVkXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vQ1NTTGludC9jc3NsaW50L3dpa2kvRG9uJ3QtdXNlLXRvby1tYW55LWZvbnQtc2l6ZS1kZWNsYXJhdGlvbnNcbiAqIEBhdXRob3IgaWVsZ25hdyh3dWppMDIyM0BnbWFpbC5jb20pXG4gKi9cblxuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCBwb3N0Y3NzIGZyb20gJ3Bvc3Rjc3MnO1xuXG4vKipcbiAqIOW9k+WJjeaWh+S7tuaJgOS7o+ihqOeahOinhOWImeWQjeensFxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgUlVMRU5BTUUgPSAnZm9udC1zaXplcyc7XG5cbi8qKlxuICog6ZSZ6K+v55qE5L+h5oGvXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBNU0cgPSAnYGZvbnQtc2l6ZWAgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuICc7XG5cbmxldCBmb250U2l6ZUNvdW50ID0gMDtcblxuLyoqXG4gKiDlhbfkvZPnmoTmo4DmtYvpgLvovpFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyDlj4LmlbBcbiAqIEBwYXJhbSB7Kn0gb3B0cy5ydWxlVmFsIOW9k+WJjeinhOWImeWFt+S9k+mFjee9rueahOWAvFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmlsZUNvbnRlbnQg5paH5Lu25YaF5a65XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5maWxlUGF0aCDmlofku7bot6/lvoRcbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrID0gcG9zdGNzcy5wbHVnaW4oUlVMRU5BTUUsIG9wdHMgPT5cbiAgICAoY3NzLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKCFvcHRzLnJ1bGVWYWwgfHwgaXNOYU4ob3B0cy5ydWxlVmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9udFNpemVDb3VudCA9IDA7XG5cbiAgICAgICAgY3NzLndhbGtEZWNscyhkZWNsID0+IHtcbiAgICAgICAgICAgIGlmIChnbG9iYWwuQ1NTSElOVF9JTlZBTElEX0FMTF9DT1VOVCA+PSBvcHRzLm1heEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9wID0gZGVjbC5wcm9wO1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdmb250LXNpemUnKSB7XG4gICAgICAgICAgICAgICAgZm9udFNpemVDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZm9udFNpemVDb3VudCA+IG9wdHMucnVsZVZhbCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gTVNHICsgb3B0cy5ydWxlVmFsICsgJywgY3VycmVudCBmaWxlIGBmb250LXNpemVgIGlzICcgKyBmb250U2l6ZUNvdW50O1xuICAgICAgICAgICAgcmVzdWx0Lndhcm4oUlVMRU5BTUUsIHtcbiAgICAgICAgICAgICAgICBub2RlOiBjc3MsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IFJVTEVOQU1FLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHN0cixcbiAgICAgICAgICAgICAgICBjb2xvck1lc3NhZ2U6IGNoYWxrLmdyZXkoc3RyKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdsb2JhbC5DU1NISU5UX0lOVkFMSURfQUxMX0NPVU5UKys7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuIl19