'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.check = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * @file require-newline 的检测逻辑
                                                                                                                                                                                                                                                                               *       `selector` 对应 008: [强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。
                                                                                                                                                                                                                                                                               *       `property` 对应 011: [强制] 属性定义必须另起一行。
                                                                                                                                                                                                                                                                               *       `media-query-condition` 对应 044: [强制] `Media Query` 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。
                                                                                                                                                                                                                                                                               * @author ielgnaw(wuji0223@gmail.com)
                                                                                                                                                                                                                                                                               */

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _util = require('../util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 当前文件所代表的规则名称
 *
 * @const
 * @type {string}
 */
var RULENAME = 'require-newline';

/**
 * 判断逗号后面没有跟着换行符的正则
 * 如果未匹配，则说明逗号后面有换行符
 *
 * @const
 * @type {RegExp}
 */
var PATTERN_NOTLF = /(,(?!\s*\n))/;

/**
 * 错误信息
 *
 * @const
 * @type {string}
 */
var MEDIA_MSG = '' + '`Media Query` if there is more than one comma separated condition,' + ' should put each on a separate line condition';

/**
 * 错误信息
 *
 * @const
 * @type {string}
 */
var SELECTOR_MSG = '' + 'When a rule contains multiple selector, ' + 'each selector statement must be on a separate line';

/**
 * 错误信息
 *
 * @const
 * @type {string}
 */
var PROPERTY_MSG = 'The attribute definition must be on a new line';

var arrayProto = Array.prototype;

/**
 * 具体的检测逻辑
 *
 * @param {Object} opts 参数
 * @param {*} opts.ruleVal 当前规则具体配置的值
 * @param {string} opts.fileContent 文件内容
 * @param {string} opts.filePath 文件路径
 */
var check = exports.check = _postcss2.default.plugin(RULENAME, function (opts) {
    return function (css, result) {

        var ruleVal = opts.ruleVal;
        var realRuleVal = [];
        arrayProto.push[Array.isArray(ruleVal) ? 'apply' : 'call'](realRuleVal, ruleVal);

        if (realRuleVal.length) {
            var _ret = function () {

                var source = void 0;
                var line = void 0;
                var lineContent = void 0;
                var col = void 0;

                if (realRuleVal.indexOf('selector') > -1) {
                    css.walkRules(function (rule) {
                        if (global.CSSHINT_INVALID_ALL_COUNT >= opts.maxError) {
                            return;
                        }

                        var selector = rule.selector;
                        if (PATTERN_NOTLF.test(selector)) {
                            source = rule.source;
                            line = source.start.line;
                            lineContent = (0, _util.getLineContent)(line, source.input.css);
                            col = source.start.column;
                            // 如果是 `p, i, \n.cc` 这样的选择器，那么高亮就应该把后面的 `\n.cc` 去掉
                            // 直接用 lineContent 来匹配 `p, i, \n.cc` 无法高亮
                            var colorStr = selector.replace(/\n.*/, '');
                            result.warn(RULENAME, {
                                node: rule,
                                ruleName: RULENAME,
                                errorChar: 'selector',
                                line: line,
                                col: col,
                                message: SELECTOR_MSG,
                                colorMessage: '`' + lineContent.replace(colorStr, _chalk2.default.magenta(colorStr)) + '` ' + _chalk2.default.grey(SELECTOR_MSG)
                            });
                            global.CSSHINT_INVALID_ALL_COUNT++;
                        }
                    });
                }

                if (realRuleVal.indexOf('media-query-condition') > -1) {
                    if (global.CSSHINT_INVALID_ALL_COUNT >= opts.maxError) {
                        return {
                            v: void 0
                        };
                    }

                    css.walkAtRules(function (atRule) {
                        if (atRule.name !== 'media') {
                            return;
                        }
                        var params = atRule.params;
                        if (PATTERN_NOTLF.test(params)) {
                            source = atRule.source;
                            line = source.start.line;
                            lineContent = (0, _util.getLineContent)(line, source.input.css);
                            col = source.start.column;

                            var colorStr = params.replace(/\n.*/, '');
                            result.warn(RULENAME, {
                                node: atRule,
                                ruleName: RULENAME,
                                errorChar: 'media-query-condition',
                                line: line,
                                col: col,
                                message: MEDIA_MSG,
                                colorMessage: '`' + lineContent.replace('@media', _chalk2.default.magenta('@media')).replace(colorStr, _chalk2.default.magenta(colorStr)) + '` ' + _chalk2.default.grey(MEDIA_MSG)
                            });
                            global.CSSHINT_INVALID_ALL_COUNT++;
                        }
                    });
                }

                if (realRuleVal.indexOf('property') > -1) {
                    css.walkDecls(function (decl) {
                        if (global.CSSHINT_INVALID_ALL_COUNT >= opts.maxError) {
                            return;
                        }

                        var before = decl.raws.before;
                        if (before.indexOf('\n') === -1) {
                            source = decl.source;
                            line = source.start.line;
                            lineContent = (0, _util.getLineContent)(line, source.input.css);
                            col = source.start.column;
                            result.warn(RULENAME, {
                                node: decl,
                                ruleName: RULENAME,
                                errorChar: 'property',
                                line: line,
                                col: col,
                                message: PROPERTY_MSG,
                                colorMessage: '`' + (0, _util.changeColorByStartAndEndIndex)(lineContent, col, source.end.column) + '` ' + _chalk2.default.grey(PROPERTY_MSG)
                            });

                            global.CSSHINT_INVALID_ALL_COUNT++;
                        }
                    });
                }
            }();

            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        }
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlL3JlcXVpcmUtbmV3bGluZS5qcyJdLCJuYW1lcyI6WyJSVUxFTkFNRSIsIlBBVFRFUk5fTk9UTEYiLCJNRURJQV9NU0ciLCJTRUxFQ1RPUl9NU0ciLCJQUk9QRVJUWV9NU0ciLCJhcnJheVByb3RvIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjaGVjayIsInBsdWdpbiIsImNzcyIsInJlc3VsdCIsInJ1bGVWYWwiLCJvcHRzIiwicmVhbFJ1bGVWYWwiLCJwdXNoIiwiaXNBcnJheSIsImxlbmd0aCIsInNvdXJjZSIsImxpbmUiLCJsaW5lQ29udGVudCIsImNvbCIsImluZGV4T2YiLCJ3YWxrUnVsZXMiLCJnbG9iYWwiLCJDU1NISU5UX0lOVkFMSURfQUxMX0NPVU5UIiwibWF4RXJyb3IiLCJzZWxlY3RvciIsInJ1bGUiLCJ0ZXN0Iiwic3RhcnQiLCJpbnB1dCIsImNvbHVtbiIsImNvbG9yU3RyIiwicmVwbGFjZSIsIndhcm4iLCJub2RlIiwicnVsZU5hbWUiLCJlcnJvckNoYXIiLCJtZXNzYWdlIiwiY29sb3JNZXNzYWdlIiwibWFnZW50YSIsImdyZXkiLCJ3YWxrQXRSdWxlcyIsImF0UnVsZSIsIm5hbWUiLCJwYXJhbXMiLCJ3YWxrRGVjbHMiLCJiZWZvcmUiLCJkZWNsIiwicmF3cyIsImVuZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs4UUFBQTs7Ozs7Ozs7QUFRQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQTs7Ozs7O0FBTUEsSUFBTUEsV0FBVyxpQkFBakI7O0FBRUE7Ozs7Ozs7QUFPQSxJQUFNQyxnQkFBZ0IsY0FBdEI7O0FBRUE7Ozs7OztBQU1BLElBQU1DLFlBQVksS0FDWixvRUFEWSxHQUVaLCtDQUZOOztBQUlBOzs7Ozs7QUFNQSxJQUFNQyxlQUFlLEtBQ2YsMENBRGUsR0FFZixvREFGTjs7QUFJQTs7Ozs7O0FBTUEsSUFBTUMsZUFBZSxnREFBckI7O0FBRUEsSUFBTUMsYUFBYUMsTUFBTUMsU0FBekI7O0FBRUE7Ozs7Ozs7O0FB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LGdCQUFNVSxJQUFOLENBQVd0QyxZQUFYO0FBWlksNkJBQXRCOztBQWVBb0IsbUNBQU9DLHlCQUFQO0FBQ0g7QUFFSixxQkE3QkQ7QUE4Qkg7QUExR21COztBQUFBO0FBMkd2QjtBQUNKLEtBbkh5QztBQUFBLENBQXpCLENBQWQiLCJmaWxlIjoicmVxdWlyZS1uZXdsaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSByZXF1aXJlLW5ld2xpbmUg55qE5qOA5rWL6YC76L6RXG4gKiAgICAgICBgc2VsZWN0b3JgIOWvueW6lCAwMDg6IFvlvLrliLZdIOW9k+S4gOS4qiBydWxlIOWMheWQq+WkmuS4qiBzZWxlY3RvciDml7bvvIzmr4/kuKrpgInmi6nlmajlo7DmmI7lv4Xpobvni6zljaDkuIDooYzjgIJcbiAqICAgICAgIGBwcm9wZXJ0eWAg5a+55bqUIDAxMTogW+W8uuWItl0g5bGe5oCn5a6a5LmJ5b+F6aG75Y+m6LW35LiA6KGM44CCXG4gKiAgICAgICBgbWVkaWEtcXVlcnktY29uZGl0aW9uYCDlr7nlupQgMDQ0OiBb5by65Yi2XSBgTWVkaWEgUXVlcnlgIOWmguaenOacieWkmuS4qumAl+WPt+WIhumalOeahOadoeS7tuaXtu+8jOW6lOWwhuavj+S4quadoeS7tuaUvuWcqOWNleeLrOS4gOihjOS4reOAglxuICogQGF1dGhvciBpZWxnbmF3KHd1amkwMjIzQGdtYWlsLmNvbSlcbiAqL1xuXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHBvc3Rjc3MgZnJvbSAncG9zdGNzcyc7XG5cbmltcG9ydCB7Z2V0TGluZUNvbnRlbnQsIGNoYW5nZUNvbG9yQnlTdGFydEFuZEVuZEluZGV4fSBmcm9tICcuLi91dGlsJztcblxuLyoqXG4gKiDlvZPliY3mlofku7bmiYDku6PooajnmoTop4TliJnlkI3np7BcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFJVTEVOQU1FID0gJ3JlcXVpcmUtbmV3bGluZSc7XG5cbi8qKlxuICog5Yik5pat6YCX5Y+35ZCO6Z2i5rKh5pyJ6Lef552A5o2i6KGM56ym55qE5q2j5YiZXG4gKiDlpoLmnpzmnKrljLnphY3vvIzliJnor7TmmI7pgJflj7flkI7pnaLmnInmjaLooYznrKZcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IFBBVFRFUk5fTk9UTEYgPSAvKCwoPyFcXHMqXFxuKSkvO1xuXG4vKipcbiAqIOmUmeivr+S/oeaBr1xuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgTUVESUFfTVNHID0gJydcbiAgICArICdgTWVkaWEgUXVlcnlgIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29tbWEgc2VwYXJhdGVkIGNvbmRpdGlvbiwnXG4gICAgKyAnIHNob3VsZCBwdXQgZWFjaCBvbiBhIHNlcGFyYXRlIGxpbmUgY29uZGl0aW9uJztcblxuLyoqXG4gKiDplJnor6/kv6Hmga9cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFNFTEVDVE9SX01TRyA9ICcnXG4gICAgKyAnV2hlbiBhIHJ1bGUgY29udGFpbnMgbXVsdGlwbGUgc2VsZWN0b3IsICdcbiAgICArICdlYWNoIHNlbGVjdG9yIHN0YXRlbWVudCBtdXN0IGJlIG9uIGEgc2VwYXJhdGUgbGluZSc7XG5cbi8qKlxuICog6ZSZ6K+v5L+h5oGvXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBQUk9QRVJUWV9NU0cgPSAnVGhlIGF0dHJpYnV0ZSBkZWZpbml0aW9uIG11c3QgYmUgb24gYSBuZXcgbGluZSc7XG5cbmNvbnN0IGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKlxuICog5YW35L2T55qE5qOA5rWL6YC76L6RXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMg5Y+C5pWwXG4gKiBAcGFyYW0geyp9IG9wdHMucnVsZVZhbCDlvZPliY3op4TliJnlhbfkvZPphY3nva7nmoTlgLxcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZpbGVDb250ZW50IOaWh+S7tuWGheWuuVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmlsZVBhdGgg5paH5Lu26Lev5b6EXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVjayA9IHBvc3Rjc3MucGx1Z2luKFJVTEVOQU1FLCBvcHRzID0+XG4gICAgKGNzcywgcmVzdWx0KSA9PiB7XG5cbiAgICAgICAgY29uc3QgcnVsZVZhbCA9IG9wdHMucnVsZVZhbDtcbiAgICAgICAgY29uc3QgcmVhbFJ1bGVWYWwgPSBbXTtcbiAgICAgICAgYXJyYXlQcm90by5wdXNoW0FycmF5LmlzQXJyYXkocnVsZVZhbCkgPyAnYXBwbHknIDogJ2NhbGwnXShyZWFsUnVsZVZhbCwgcnVsZVZhbCk7XG5cbiAgICAgICAgaWYgKHJlYWxSdWxlVmFsLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICAgICAgbGV0IGxpbmU7XG4gICAgICAgICAgICBsZXQgbGluZUNvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgY29sO1xuXG4gICAgICAgICAgICBpZiAocmVhbFJ1bGVWYWwuaW5kZXhPZignc2VsZWN0b3InKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY3NzLndhbGtSdWxlcyhydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbC5DU1NISU5UX0lOVkFMSURfQUxMX0NPVU5UID49IG9wdHMubWF4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBBVFRFUk5fTk9UTEYudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJ1bGUuc291cmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IHNvdXJjZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNvbnRlbnQgPSBnZXRMaW5lQ29udGVudChsaW5lLCBzb3VyY2UuaW5wdXQuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IHNvdXJjZS5zdGFydC5jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmmK8gYHAsIGksIFxcbi5jY2Ag6L+Z5qC355qE6YCJ5oup5Zmo77yM6YKj5LmI6auY5Lqu5bCx5bqU6K+l5oqK5ZCO6Z2i55qEIGBcXG4uY2NgIOWOu+aOiVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l55SoIGxpbmVDb250ZW50IOadpeWMuemFjSBgcCwgaSwgXFxuLmNjYCDml6Dms5Xpq5jkuq5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yU3RyID0gc2VsZWN0b3IucmVwbGFjZSgvXFxuLiovLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQud2FybihSVUxFTkFNRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IHJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWU6IFJVTEVOQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2hhcjogJ3NlbGVjdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNFTEVDVE9SX01TRyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvck1lc3NhZ2U6ICdgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGxpbmVDb250ZW50LnJlcGxhY2UoY29sb3JTdHIsIGNoYWxrLm1hZ2VudGEoY29sb3JTdHIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdgICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBjaGFsay5ncmV5KFNFTEVDVE9SX01TRylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLkNTU0hJTlRfSU5WQUxJRF9BTExfQ09VTlQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZWFsUnVsZVZhbC5pbmRleE9mKCdtZWRpYS1xdWVyeS1jb25kaXRpb24nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbC5DU1NISU5UX0lOVkFMSURfQUxMX0NPVU5UID49IG9wdHMubWF4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNzcy53YWxrQXRSdWxlcyhhdFJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXRSdWxlLm5hbWUgIT09ICdtZWRpYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhdFJ1bGUucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUEFUVEVSTl9OT1RMRi50ZXN0KHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGF0UnVsZS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQ29udGVudCA9IGdldExpbmVDb250ZW50KGxpbmUsIHNvdXJjZS5pbnB1dC5jc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gc291cmNlLnN0YXJ0LmNvbHVtbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3JTdHIgPSBwYXJhbXMucmVwbGFjZSgvXFxuLiovLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQud2FybihSVUxFTkFNRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGF0UnVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlTmFtZTogUlVMRU5BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDaGFyOiAnbWVkaWEtcXVlcnktY29uZGl0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IE1FRElBX01TRyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvck1lc3NhZ2U6ICdgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGxpbmVDb250ZW50LnJlcGxhY2UoJ0BtZWRpYScsIGNoYWxrLm1hZ2VudGEoJ0BtZWRpYScpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoY29sb3JTdHIsIGNoYWxrLm1hZ2VudGEoY29sb3JTdHIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdgICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBjaGFsay5ncmV5KE1FRElBX01TRylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLkNTU0hJTlRfSU5WQUxJRF9BTExfQ09VTlQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVhbFJ1bGVWYWwuaW5kZXhPZigncHJvcGVydHknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY3NzLndhbGtEZWNscyhkZWNsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbC5DU1NISU5UX0lOVkFMSURfQUxMX0NPVU5UID49IG9wdHMubWF4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGRlY2wucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUuaW5kZXhPZignXFxuJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBkZWNsLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBzb3VyY2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb250ZW50ID0gZ2V0TGluZUNvbnRlbnQobGluZSwgc291cmNlLmlucHV0LmNzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBzb3VyY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lndhcm4oUlVMRU5BTUUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBkZWNsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBSVUxFTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNoYXI6ICdwcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBQUk9QRVJUWV9NU0csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JNZXNzYWdlOiAnYCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBjaGFuZ2VDb2xvckJ5U3RhcnRBbmRFbmRJbmRleChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb250ZW50LCBjb2wsIHNvdXJjZS5lbmQuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnYCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgY2hhbGsuZ3JleShQUk9QRVJUWV9NU0cpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLkNTU0hJTlRfSU5WQUxJRF9BTExfQ09VTlQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4pO1xuIl19