'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.check = undefined;

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _util = require('../util');

var _prefixes = require('../prefixes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @file block-indent 的检测逻辑
 *       002: [强制] 使用 `4` 个空格做为一个缩进层级，不允许使用 `2` 个空格 或 `tab` 字符。
 * @author ielgnaw(wuji0223@gmail.com)
 */

'use strict';

var prefixList = (0, _prefixes.getPrefixList)();

/**
 * 当前文件所代表的规则名称
 *
 * @const
 * @type {string}
 */
var RULENAME = 'block-indent';

/**
 * 行号的缓存，防止同一行多次报错
 *
 * @type {number}
 */
var lineCache = 0;

/**
 * 获取错误信息
 *
 * @param {string} curIndentStr 当前的缩进的字符串（错误的）
 * @param {string} neededIndentStr 期望的的缩进的字符串（正确的）
 *
 * @return {string} 错误信息
 */
var getMsg = function getMsg(curIndentStr, neededIndentStr) {
    return '' + 'Bad indentation, Expected `' + neededIndentStr.length + '` but saw `' + curIndentStr.length + '`';
};

/**
 * 判断是否是合法的带前缀的 css 属性名称
 *
 * @param {Object} decl postcss 节点对象
 *
 * @return {boolean} 结果
 */
var isValidVendorProp = function isValidVendorProp(decl) {
    var prop = decl.prop;
    var standardProperty = prop.replace(/^\-(webkit|moz|ms|o)\-/g, '');
    // 标准模式在 prefixList 中，那么如果 propertyName 不在 prefixList 中
    // 即这个属性用错了，例如 -o-animation
    if (prefixList.indexOf(standardProperty) > -1) {
        if (prefixList.indexOf(prop) <= -1) {
            return false;
        }
    }
    return true;
};

/**
 * 对 decl 的处理
 *
 * @param {Object} node node 对象，可能是 decl 也可能是 rule
 * @param {Object} result postcss 转换的结果对象
 * @param {string} msg 错误信息
 * @param {string} hackPrefixChar 属性 hack 的前缀，`_` 或者 `*`
 */
var addWarn = function addWarn(node, result, msg, hackPrefixChar) {
    var source = node.source;
    var line = source.start.line;
    if (lineCache !== line) {
        lineCache = line;
        var col = source.start.column;

        var lineContent = (0, _util.getLineContent)(line, source.input.css) || '';
        var colorStr = '';

        if (node.selector) {
            colorStr = node.selector;
        } else if (node.type === 'atrule') {
            colorStr = lineContent;
        } else {
            colorStr = (hackPrefixChar || '') + node.prop + node.raws.between + node.value;
            colorStr = colorStr.replace(/\n/g, '');
        }

        result.warn(RULENAME, {
            node: node,
            ruleName: RULENAME,
            line: line,
            col: col,
            message: msg,
            colorMessage: '`' + lineContent.replace(colorStr, _chalk2.default.magenta(colorStr)) + '` ' + _chalk2.default.grey(msg)
        });
        global.CSSHINT_INVALID_ALL_COUNT++;
    }
};

/**
 * 对 atRuleList 的处理，上下文是 atRuleList
 *
 * @param {Array} atRuleList arRule 对象集合
 * @param {Object} result postcss result 对象
 * @param {Object} rule css.walkRules 里的 rule 对象
 * @param {string} indentStr 缩进的字符串
 * @param {number} startPos 开始计算缩进的偏移量，相当于这一行的 column，和 indentStr 没有关系
 */
var atRuleListIterator = function atRuleListIterator(atRuleList, result, rule, indentStr, startPos) {
    // 说明当前这个选择器没有 atRule
    if (!atRuleList.length) {
        (function () {
            var ruleStartCol = rule.source.start.column;
            if (ruleStartCol - 1 !== startPos) {
                addWarn(rule, result, getMsg(rule.raws.before.replace(/\n/g, ''), ''));
            }

            // 选择器中的属性默认的缩进层级为 1
            var indentLevel = 1;
            rule.walkDecls(function (decl) {
                if (!isValidVendorProp(decl, result)) {
                    return;
                }

                if (prefixList.indexOf(decl.prop) > -1) {
                    return;
                }

                var ruleBefore = rule.raws.before;

                // 加上 \s，是为了防止如下情况
                // div {
                //     color: #fff;
                // }
                // span {
                //     color: #000;
                // }
                // 当 div 的 } 符号后有一个空格的时候，会导致 span 的第一条非注释属性报 block-indent 的错误
                // \s\s\s\n\n\s\s\s 要去掉 \n 前面的 \s，\n 后面的 \s 需要计算为下一行的开头位置，所以不能去掉
                ruleBefore = ruleBefore.replace(/\s*\n+/, '');

                // 正确的缩进字符串
                var shouldIndentStr = ruleBefore;
                for (var j = 0; j < indentLevel; j++) {
                    shouldIndentStr += indentStr;
                }

                var declBefore = decl.raws.before;
                // 兼容 background-position-x: 170px;; 属性后有多个分号的情况
                declBefore = declBefore.replace(/^[^\n]*/, '');
                // 把 before 里面的多个空行换成一个，便于之后的计算
                declBefore = declBefore.replace(/\n*/, '\n');

                var length = declBefore.length;
                var hackPrefixChar = declBefore[length - 1];
                if (hackPrefixChar === '_' || hackPrefixChar === '*') {
                    shouldIndentStr += hackPrefixChar;
                }

                if (declBefore !== '\n' + shouldIndentStr) {
                    addWarn(decl, result, getMsg(declBefore.replace(/\n/g, '').slice(0, -1), shouldIndentStr.slice(0, -1)));
                }
            });
        })();
    }

    // 对 atRule 处理
    atRuleList.forEach(function (ar, index) {
        var raws = ar.raws,
            source = ar.source;

        var arBefore = raws.before;
        // 兼容 background-position-x: 170px;; 属性后有多个分号的情况
        arBefore = arBefore.replace(/^[^\n]*/, '');
        // 把 arBefore 里面的多个空行换成一个，便于之后的计算
        arBefore = arBefore.replace(/\n*/, '\n');

        var startCol = source.start.column;

        // 判断第一行，只需要看开头的 col 是否等于 startPos
        if (index === 0) {
            if (startCol - 1 !== startPos) {
                addWarn(ar, result, getMsg(arBefore.replace(/\n/g, ''), ''));
            }
        }
        // 非第一行的 @ 选择器，那么开头就必须有缩进，缩进根据 indentStr 来计算
        else {
                // 正确的缩进字符串
                var shouldIndentStr = '';
                for (var i = 0; i < index; i++) {
                    shouldIndentStr += indentStr;
                }

                if (arBefore !== '\n' + shouldIndentStr) {
                    addWarn(ar, result, getMsg(arBefore.replace(/\n/g, '').slice(0, -1), shouldIndentStr.slice(0, -1)));
                }
            }

        // 最后一个 @ 选择器，在这里处理 atRule 里的 decl 以及 atRule 里的 rule
        if (index === atRuleList.length - 1) {
            var ruleBefore = rule.raws.before;
            // 兼容 background-position-x: 170px;; 属性后有多个分号的情况
            ruleBefore = ruleBefore.replace(/^[^\n]*/, '');
            // 把 ruleBefore 里面的多个空行换成一个，便于之后的计算
            ruleBefore = ruleBefore.replace(/\n*/, '\n');

            // 正确的缩进字符串
            var ruleShouldIndentStr = '';
            for (var q = 0; q <= index; q++) {
                ruleShouldIndentStr += indentStr;
            }

            if (ruleBefore !== '\n' + ruleShouldIndentStr) {
                addWarn(rule, result, getMsg(ruleBefore.replace(/\n/g, '').slice(0, -1), ruleShouldIndentStr.slice(0, -1)));
            }

            // 处理 atRule 里面的 decl，其实这里用 rule.walkDecls 也可以
            ar.walkDecls(function (decl) {
                if (!isValidVendorProp(decl, result)) {
                    return;
                }

                if (prefixList.indexOf(decl.prop) > -1) {
                    return;
                }

                var before = decl.raws.before;
                // 兼容 background-position-x: 170px;; 属性后有多个分号的情况
                before = before.replace(/^[^\n]*/, '');
                // 把 before 里面的多个空行换成一个，便于之后的计算
                before = before.replace(/\n*/, '\n');

                // 正确的缩进字符串
                var shouldIndentStr = '';
                // 属性时 index 要加 1，因为这个 index 是 rule 的 index，而属性和 rule 之间要有一个缩进
                for (var _i = 0; _i <= index + 1; _i++) {
                    shouldIndentStr += indentStr;
                }

                var length = before.length;
                var hackPrefixChar = before[length - 1];
                if (hackPrefixChar === '_' || hackPrefixChar === '*') {
                    shouldIndentStr += hackPrefixChar;
                }

                if (before !== '\n' + shouldIndentStr) {
                    addWarn(decl, result, getMsg(before.replace(/\n/g, '').slice(0, -1), shouldIndentStr.slice(0, -1)));
                }
            });
        }
    });
};

/**
 * 具体的检测逻辑
 *
 * @param {Object} opts 参数
 * @param {*} opts.ruleVal 当前规则具体配置的值
 * @param {string} opts.fileContent 文件内容
 * @param {string} opts.filePath 文件路径
 */
var check = exports.check = _postcss2.default.plugin(RULENAME, function (opts) {
    return function (css, result) {
        if (!Array.isArray(opts.ruleVal)) {
            return;
        }

        lineCache = 0;

        // 缩进的字符串
        var indentStr = opts.ruleVal[0];

        // 开始计算缩进的偏移量，相当于这一行的 column，和 opts.ruleVal[0] 没有关系
        var startPos = opts.ruleVal[1];

        css.walkRules(function (rule) {

            if (global.CSSHINT_INVALID_ALL_COUNT >= opts.maxError) {
                return;
            }

            // 这里用 atRuleList 对 atRule 做一下处理是因为 postcss 默认是从 decl -> atrule -> rule -> root
            // 即从里向外的顺序处理的，但是我们这里需要知道由里向外的层级，我们需要知道层级的开始以及结束点
            // 因此 atRuleList.unshift 这样倒序过来
            var atRuleList = [];
            var parentRule = rule.parent;
            while (parentRule.type === 'atrule') {
                atRuleList.unshift(parentRule);
                parentRule = parentRule.parent;
            }

            atRuleListIterator(atRuleList, result, rule, indentStr, startPos);
        });
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlL2Jsb2NrLWluZGVudC5qcyJdLCJuYW1lcyI6WyJwcmVmaXhMaXN0IiwiUlVMRU5BTUUiLCJsaW5lQ2FjaGUiLCJnZXRNc2ciLCJjdXJJbmRlbnRTdHIiLCJuZWVkZWRJbmRlbnRTdHIiLCJsZW5ndGgiLCJpc1ZhbGlkVmVuZG9yUHJvcCIsInByb3AiLCJkZWNsIiwic3RhbmRhcmRQcm9wZXJ0eSIsInJlcGxhY2UiLCJpbmRleE9mIiwiYWRkV2FybiIsIm5vZGUiLCJyZXN1bHQiLCJtc2ciLCJoYWNrUHJlZml4Q2hhciIsInNvdXJjZSIsImxpbmUiLCJzdGFydCIsImNvbCIsImNvbHVtbiIsImxpbmVDb250ZW50IiwiaW5wdXQiLCJjc3MiLCJjb2xvclN0ciIsInNlbGVjdG9yIiwidHlwZSIsInJhd3MiLCJiZXR3ZWVuIiwidmFsdWUiLCJ3YXJuIiwicnVsZU5hbWUiLCJtZXNzYWdlIiwiY29sb3JNZXNzYWdlIiwibWFnZW50YSIsImdyZXkiLCJnbG9iYWwiLCJDU1NISU5UX0lOVkFMSURfQUxMX0NPVU5UIiwiYXRSdWxlTGlzdEl0ZXJhdG9yIiwiYXRSdWxlTGlzdCIsInJ1bGUiLCJpbmRlbnRTdHIiLCJzdGFydFBvcyIsInJ1bGVTdGFydENvbCIsImJlZm9yZSIsImluZGVudExldmVsIiwid2Fsa0RlY2xzIiwicnVsZUJlZm9yZSIsInNob3VsZEluZGVudFN0ciIsImoiLCJkZWNsQmVmb3JlIiwic2xpY2UiLCJmb3JFYWNoIiwiYXIiLCJpbmRleCIsImFyQmVmb3JlIiwic3RhcnRDb2wiLCJpIiwicnVsZVNob3VsZEluZGVudFN0ciIsInEiLCJjaGVjayIsInBsdWdpbiIsIkFycmF5IiwiaXNBcnJheSIsIm9wdHMiLCJydWxlVmFsIiwid2Fsa1J1bGVzIiwibWF4RXJyb3IiLCJwYXJlbnRSdWxlIiwicGFyZW50IiwidW5zaGlmdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQU1BOzs7O0FBQ0E7Ozs7QUFFQTs7QUFFQTs7OztBQVhB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LFdBQzFDLFVBQUN3QixHQUFELEVBQU1WLE1BQU4sRUFBaUI7QUFDYixZQUFJLENBQUNpRCxNQUFNQyxPQUFOLENBQWNDLEtBQUtDLE9BQW5CLENBQUwsRUFBa0M7QUFDOUI7QUFDSDs7QUFHRGpFLG9CQUFZLENBQVo7O0FBRUE7QUFDQSxZQUFNeUMsWUFBWXVCLEtBQUtDLE9BQUwsQ0FBYSxDQUFiLENBQWxCOztBQUVBO0FBQ0EsWUFBTXZCLFdBQVdzQixLQUFLQyxPQUFMLENBQWEsQ0FBYixDQUFqQjs7QUFFQTFDLFlBQUkyQyxTQUFKLENBQWMsZ0JBQVE7O0FBRWxCLGdCQUFJOUIsT0FBT0MseUJBQVAsSUFBb0MyQixLQUFLRyxRQUE3QyxFQUF1RDtBQUNuRDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdCQUFNNUIsYUFBYSxFQUFuQjtBQUNBLGdCQUFJNkIsYUFBYTVCLEtBQUs2QixNQUF0QjtBQUNBLG1CQUFPRCxXQUFXMUMsSUFBWCxLQUFvQixRQUEzQixFQUFxQztBQUNqQ2EsMkJBQVcrQixPQUFYLENBQW1CRixVQUFuQjtBQUNBQSw2QkFBYUEsV0FBV0MsTUFBeEI7QUFDSDs7QUFFRC9CLCtCQUFtQkMsVUFBbkIsRUFBK0IxQixNQUEvQixFQUF1QzJCLElBQXZDLEVBQTZDQyxTQUE3QyxFQUF3REMsUUFBeEQ7QUFDSCxTQWpCRDtBQWtCSCxLQWpDeUM7QUFBQSxDQUF6QixDQUFkIiwiZmlsZSI6ImJsb2NrLWluZGVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgYmxvY2staW5kZW50IOeahOajgOa1i+mAu+i+kVxuICogICAgICAgMDAyOiBb5by65Yi2XSDkvb/nlKggYDRgIOS4quepuuagvOWBmuS4uuS4gOS4que8qei/m+Wxgue6p++8jOS4jeWFgeiuuOS9v+eUqCBgMmAg5Liq56m65qC8IOaIliBgdGFiYCDlrZfnrKbjgIJcbiAqIEBhdXRob3IgaWVsZ25hdyh3dWppMDIyM0BnbWFpbC5jb20pXG4gKi9cblxuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCBwb3N0Y3NzIGZyb20gJ3Bvc3Rjc3MnO1xuXG5pbXBvcnQge2dldExpbmVDb250ZW50fSBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtnZXRQcmVmaXhMaXN0fSBmcm9tICcuLi9wcmVmaXhlcyc7XG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJlZml4TGlzdCA9IGdldFByZWZpeExpc3QoKTtcblxuLyoqXG4gKiDlvZPliY3mlofku7bmiYDku6PooajnmoTop4TliJnlkI3np7BcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFJVTEVOQU1FID0gJ2Jsb2NrLWluZGVudCc7XG5cbi8qKlxuICog6KGM5Y+355qE57yT5a2Y77yM6Ziy5q2i5ZCM5LiA6KGM5aSa5qyh5oql6ZSZXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xubGV0IGxpbmVDYWNoZSA9IDA7XG5cbi8qKlxuICog6I635Y+W6ZSZ6K+v5L+h5oGvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGN1ckluZGVudFN0ciDlvZPliY3nmoTnvKnov5vnmoTlrZfnrKbkuLLvvIjplJnor6/nmoTvvIlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZWVkZWRJbmRlbnRTdHIg5pyf5pyb55qE55qE57yp6L+b55qE5a2X56ym5Liy77yI5q2j56Gu55qE77yJXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSDplJnor6/kv6Hmga9cbiAqL1xuY29uc3QgZ2V0TXNnID0gKGN1ckluZGVudFN0ciwgbmVlZGVkSW5kZW50U3RyKSA9PlxuICAgICcnXG4gICAgICAgICsgJ0JhZCBpbmRlbnRhdGlvbiwgRXhwZWN0ZWQgYCdcbiAgICAgICAgKyAobmVlZGVkSW5kZW50U3RyLmxlbmd0aClcbiAgICAgICAgKyAnYCBidXQgc2F3IGAnXG4gICAgICAgICsgKGN1ckluZGVudFN0ci5sZW5ndGgpXG4gICAgICAgICsgJ2AnO1xuXG4vKipcbiAqIOWIpOaWreaYr+WQpuaYr+WQiOazleeahOW4puWJjee8gOeahCBjc3Mg5bGe5oCn5ZCN56ewXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlY2wgcG9zdGNzcyDoioLngrnlr7nosaFcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSDnu5PmnpxcbiAqL1xuY29uc3QgaXNWYWxpZFZlbmRvclByb3AgPSBkZWNsID0+IHtcbiAgICBjb25zdCBwcm9wID0gZGVjbC5wcm9wO1xuICAgIGNvbnN0IHN0YW5kYXJkUHJvcGVydHkgPSBwcm9wLnJlcGxhY2UoL15cXC0od2Via2l0fG1venxtc3xvKVxcLS9nLCAnJyk7XG4gICAgLy8g5qCH5YeG5qih5byP5ZyoIHByZWZpeExpc3Qg5Lit77yM6YKj5LmI5aaC5p6cIHByb3BlcnR5TmFtZSDkuI3lnKggcHJlZml4TGlzdCDkuK1cbiAgICAvLyDljbPov5nkuKrlsZ7mgKfnlKjplJnkuobvvIzkvovlpoIgLW8tYW5pbWF0aW9uXG4gICAgaWYgKHByZWZpeExpc3QuaW5kZXhPZihzdGFuZGFyZFByb3BlcnR5KSA+IC0xKSB7XG4gICAgICAgIGlmIChwcmVmaXhMaXN0LmluZGV4T2YocHJvcCkgPD0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICog5a+5IGRlY2wg55qE5aSE55CGXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgbm9kZSDlr7nosaHvvIzlj6/og73mmK8gZGVjbCDkuZ/lj6/og73mmK8gcnVsZVxuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBwb3N0Y3NzIOi9rOaNoueahOe7k+aenOWvueixoVxuICogQHBhcmFtIHtzdHJpbmd9IG1zZyDplJnor6/kv6Hmga9cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYWNrUHJlZml4Q2hhciDlsZ7mgKcgaGFjayDnmoTliY3nvIDvvIxgX2Ag5oiW6ICFIGAqYFxuICovXG5jb25zdCBhZGRXYXJuID0gKG5vZGUsIHJlc3VsdCwgbXNnLCBoYWNrUHJlZml4Q2hhcikgPT4ge1xuICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUuc291cmNlO1xuICAgIGNvbnN0IGxpbmUgPSBzb3VyY2Uuc3RhcnQubGluZTtcbiAgICBpZiAobGluZUNhY2hlICE9PSBsaW5lKSB7XG4gICAgICAgIGxpbmVDYWNoZSA9IGxpbmU7XG4gICAgICAgIGNvbnN0IGNvbCA9IHNvdXJjZS5zdGFydC5jb2x1bW47XG5cbiAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSBnZXRMaW5lQ29udGVudChsaW5lLCBzb3VyY2UuaW5wdXQuY3NzKSB8fCAnJztcbiAgICAgICAgbGV0IGNvbG9yU3RyID0gJyc7XG5cbiAgICAgICAgaWYgKG5vZGUuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbG9yU3RyID0gbm9kZS5zZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdhdHJ1bGUnKSB7XG4gICAgICAgICAgICBjb2xvclN0ciA9IGxpbmVDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29sb3JTdHIgPSAoaGFja1ByZWZpeENoYXIgfHwgJycpICsgbm9kZS5wcm9wICsgbm9kZS5yYXdzLmJldHdlZW4gKyBub2RlLnZhbHVlO1xuICAgICAgICAgICAgY29sb3JTdHIgPSBjb2xvclN0ci5yZXBsYWNlKC9cXG4vZywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0Lndhcm4oUlVMRU5BTUUsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBydWxlTmFtZTogUlVMRU5BTUUsXG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICBjb2xvck1lc3NhZ2U6ICdgJ1xuICAgICAgICAgICAgICAgICsgbGluZUNvbnRlbnQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgY29sb3JTdHIsXG4gICAgICAgICAgICAgICAgICAgIGNoYWxrLm1hZ2VudGEoY29sb3JTdHIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICsgJ2AgJ1xuICAgICAgICAgICAgICAgICsgY2hhbGsuZ3JleShtc2cpXG4gICAgICAgIH0pO1xuICAgICAgICBnbG9iYWwuQ1NTSElOVF9JTlZBTElEX0FMTF9DT1VOVCsrO1xuICAgIH1cbn07XG5cbi8qKlxuICog5a+5IGF0UnVsZUxpc3Qg55qE5aSE55CG77yM5LiK5LiL5paH5pivIGF0UnVsZUxpc3RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhdFJ1bGVMaXN0IGFyUnVsZSDlr7nosaHpm4blkIhcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgcG9zdGNzcyByZXN1bHQg5a+56LGhXG4gKiBAcGFyYW0ge09iamVjdH0gcnVsZSBjc3Mud2Fsa1J1bGVzIOmHjOeahCBydWxlIOWvueixoVxuICogQHBhcmFtIHtzdHJpbmd9IGluZGVudFN0ciDnvKnov5vnmoTlrZfnrKbkuLJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvcyDlvIDlp4vorqHnrpfnvKnov5vnmoTlgY/np7vph4/vvIznm7jlvZPkuo7ov5nkuIDooYznmoQgY29sdW1u77yM5ZKMIGluZGVudFN0ciDmsqHmnInlhbPns7tcbiAqL1xuY29uc3QgYXRSdWxlTGlzdEl0ZXJhdG9yID0gKGF0UnVsZUxpc3QsIHJlc3VsdCwgcnVsZSwgaW5kZW50U3RyLCBzdGFydFBvcykgPT4ge1xuICAgIC8vIOivtOaYjuW9k+WJjei/meS4qumAieaLqeWZqOayoeaciSBhdFJ1bGVcbiAgICBpZiAoIWF0UnVsZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVTdGFydENvbCA9IHJ1bGUuc291cmNlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgaWYgKHJ1bGVTdGFydENvbCAtIDEgIT09IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICBhZGRXYXJuKHJ1bGUsIHJlc3VsdCwgZ2V0TXNnKHJ1bGUucmF3cy5iZWZvcmUucmVwbGFjZSgvXFxuL2csICcnKSwgJycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOmAieaLqeWZqOS4reeahOWxnuaAp+m7mOiupOeahOe8qei/m+Wxgue6p+S4uiAxXG4gICAgICAgIGNvbnN0IGluZGVudExldmVsID0gMTtcbiAgICAgICAgcnVsZS53YWxrRGVjbHMoZGVjbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRWZW5kb3JQcm9wKGRlY2wsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVmaXhMaXN0LmluZGV4T2YoZGVjbC5wcm9wKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcnVsZUJlZm9yZSA9IHJ1bGUucmF3cy5iZWZvcmU7XG5cbiAgICAgICAgICAgIC8vIOWKoOS4iiBcXHPvvIzmmK/kuLrkuobpmLLmraLlpoLkuIvmg4XlhrVcbiAgICAgICAgICAgIC8vIGRpdiB7XG4gICAgICAgICAgICAvLyAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBzcGFuIHtcbiAgICAgICAgICAgIC8vICAgICBjb2xvcjogIzAwMDtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIOW9kyBkaXYg55qEIH0g56ym5Y+35ZCO5pyJ5LiA5Liq56m65qC855qE5pe25YCZ77yM5Lya5a+86Ie0IHNwYW4g55qE56ys5LiA5p2h6Z2e5rOo6YeK5bGe5oCn5oqlIGJsb2NrLWluZGVudCDnmoTplJnor69cbiAgICAgICAgICAgIC8vIFxcc1xcc1xcc1xcblxcblxcc1xcc1xccyDopoHljrvmjokgXFxuIOWJjemdoueahCBcXHPvvIxcXG4g5ZCO6Z2i55qEIFxccyDpnIDopoHorqHnrpfkuLrkuIvkuIDooYznmoTlvIDlpLTkvY3nva7vvIzmiYDku6XkuI3og73ljrvmjolcbiAgICAgICAgICAgIHJ1bGVCZWZvcmUgPSBydWxlQmVmb3JlLnJlcGxhY2UoL1xccypcXG4rLywgJycpO1xuXG4gICAgICAgICAgICAvLyDmraPnoa7nmoTnvKnov5vlrZfnrKbkuLJcbiAgICAgICAgICAgIGxldCBzaG91bGRJbmRlbnRTdHIgPSBydWxlQmVmb3JlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRlbnRMZXZlbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW5kZW50U3RyICs9IGluZGVudFN0cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRlY2xCZWZvcmUgPSBkZWNsLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgLy8g5YW85a65IGJhY2tncm91bmQtcG9zaXRpb24teDogMTcwcHg7OyDlsZ7mgKflkI7mnInlpJrkuKrliIblj7fnmoTmg4XlhrVcbiAgICAgICAgICAgIGRlY2xCZWZvcmUgPSBkZWNsQmVmb3JlLnJlcGxhY2UoL15bXlxcbl0qLywgJycpO1xuICAgICAgICAgICAgLy8g5oqKIGJlZm9yZSDph4zpnaLnmoTlpJrkuKrnqbrooYzmjaLmiJDkuIDkuKrvvIzkvr/kuo7kuYvlkI7nmoTorqHnrpdcbiAgICAgICAgICAgIGRlY2xCZWZvcmUgPSBkZWNsQmVmb3JlLnJlcGxhY2UoL1xcbiovLCAnXFxuJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGRlY2xCZWZvcmUubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGFja1ByZWZpeENoYXIgPSBkZWNsQmVmb3JlW2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGhhY2tQcmVmaXhDaGFyID09PSAnXycgfHwgaGFja1ByZWZpeENoYXIgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHNob3VsZEluZGVudFN0ciArPSBoYWNrUHJlZml4Q2hhcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlY2xCZWZvcmUgIT09ICdcXG4nICsgc2hvdWxkSW5kZW50U3RyKSB7XG4gICAgICAgICAgICAgICAgYWRkV2FybihkZWNsLCByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGdldE1zZyhkZWNsQmVmb3JlLnJlcGxhY2UoL1xcbi9nLCAnJykuc2xpY2UoMCwgLTEpLCBzaG91bGRJbmRlbnRTdHIuc2xpY2UoMCwgLTEpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIOWvuSBhdFJ1bGUg5aSE55CGXG4gICAgYXRSdWxlTGlzdC5mb3JFYWNoKChhciwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qge3Jhd3MsIHNvdXJjZX0gPSBhcjtcbiAgICAgICAgbGV0IGFyQmVmb3JlID0gcmF3cy5iZWZvcmU7XG4gICAgICAgIC8vIOWFvOWuuSBiYWNrZ3JvdW5kLXBvc2l0aW9uLXg6IDE3MHB4Ozsg5bGe5oCn5ZCO5pyJ5aSa5Liq5YiG5Y+355qE5oOF5Ya1XG4gICAgICAgIGFyQmVmb3JlID0gYXJCZWZvcmUucmVwbGFjZSgvXlteXFxuXSovLCAnJyk7XG4gICAgICAgIC8vIOaKiiBhckJlZm9yZSDph4zpnaLnmoTlpJrkuKrnqbrooYzmjaLmiJDkuIDkuKrvvIzkvr/kuo7kuYvlkI7nmoTorqHnrpdcbiAgICAgICAgYXJCZWZvcmUgPSBhckJlZm9yZS5yZXBsYWNlKC9cXG4qLywgJ1xcbicpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0Q29sID0gc291cmNlLnN0YXJ0LmNvbHVtbjtcblxuICAgICAgICAvLyDliKTmlq3nrKzkuIDooYzvvIzlj6rpnIDopoHnnIvlvIDlpLTnmoQgY29sIOaYr+WQpuetieS6jiBzdGFydFBvc1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdGFydENvbCAtIDEgIT09IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgYWRkV2FybihhciwgcmVzdWx0LCBnZXRNc2coYXJCZWZvcmUucmVwbGFjZSgvXFxuL2csICcnKSwgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyDpnZ7nrKzkuIDooYznmoQgQCDpgInmi6nlmajvvIzpgqPkuYjlvIDlpLTlsLHlv4XpobvmnInnvKnov5vvvIznvKnov5vmoLnmja4gaW5kZW50U3RyIOadpeiuoeeul1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIOato+ehrueahOe8qei/m+Wtl+espuS4slxuICAgICAgICAgICAgbGV0IHNob3VsZEluZGVudFN0ciA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW5kZW50U3RyICs9IGluZGVudFN0cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFyQmVmb3JlICE9PSAnXFxuJyArIHNob3VsZEluZGVudFN0cikge1xuICAgICAgICAgICAgICAgIGFkZFdhcm4oYXIsIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TXNnKGFyQmVmb3JlLnJlcGxhY2UoL1xcbi9nLCAnJykuc2xpY2UoMCwgLTEpLCBzaG91bGRJbmRlbnRTdHIuc2xpY2UoMCwgLTEpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmnIDlkI7kuIDkuKogQCDpgInmi6nlmajvvIzlnKjov5nph4zlpITnkIYgYXRSdWxlIOmHjOeahCBkZWNsIOS7peWPiiBhdFJ1bGUg6YeM55qEIHJ1bGVcbiAgICAgICAgaWYgKGluZGV4ID09PSBhdFJ1bGVMaXN0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGxldCBydWxlQmVmb3JlID0gcnVsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgIC8vIOWFvOWuuSBiYWNrZ3JvdW5kLXBvc2l0aW9uLXg6IDE3MHB4Ozsg5bGe5oCn5ZCO5pyJ5aSa5Liq5YiG5Y+355qE5oOF5Ya1XG4gICAgICAgICAgICBydWxlQmVmb3JlID0gcnVsZUJlZm9yZS5yZXBsYWNlKC9eW15cXG5dKi8sICcnKTtcbiAgICAgICAgICAgIC8vIOaKiiBydWxlQmVmb3JlIOmHjOmdoueahOWkmuS4quepuuihjOaNouaIkOS4gOS4qu+8jOS+v+S6juS5i+WQjueahOiuoeeul1xuICAgICAgICAgICAgcnVsZUJlZm9yZSA9IHJ1bGVCZWZvcmUucmVwbGFjZSgvXFxuKi8sICdcXG4nKTtcblxuICAgICAgICAgICAgLy8g5q2j56Gu55qE57yp6L+b5a2X56ym5LiyXG4gICAgICAgICAgICBsZXQgcnVsZVNob3VsZEluZGVudFN0ciA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgcSA9IDA7IHEgPD0gaW5kZXg7IHErKykge1xuICAgICAgICAgICAgICAgIHJ1bGVTaG91bGRJbmRlbnRTdHIgKz0gaW5kZW50U3RyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocnVsZUJlZm9yZSAhPT0gJ1xcbicgKyBydWxlU2hvdWxkSW5kZW50U3RyKSB7XG4gICAgICAgICAgICAgICAgYWRkV2FybihydWxlLCByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGdldE1zZyhydWxlQmVmb3JlLnJlcGxhY2UoL1xcbi9nLCAnJykuc2xpY2UoMCwgLTEpLCBydWxlU2hvdWxkSW5kZW50U3RyLnNsaWNlKDAsIC0xKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDlpITnkIYgYXRSdWxlIOmHjOmdoueahCBkZWNs77yM5YW25a6e6L+Z6YeM55SoIHJ1bGUud2Fsa0RlY2xzIOS5n+WPr+S7pVxuICAgICAgICAgICAgYXIud2Fsa0RlY2xzKGRlY2wgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFZlbmRvclByb3AoZGVjbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeExpc3QuaW5kZXhPZihkZWNsLnByb3ApID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBkZWNsLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIC8vIOWFvOWuuSBiYWNrZ3JvdW5kLXBvc2l0aW9uLXg6IDE3MHB4Ozsg5bGe5oCn5ZCO5pyJ5aSa5Liq5YiG5Y+355qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgYmVmb3JlID0gYmVmb3JlLnJlcGxhY2UoL15bXlxcbl0qLywgJycpO1xuICAgICAgICAgICAgICAgIC8vIOaKiiBiZWZvcmUg6YeM6Z2i55qE5aSa5Liq56m66KGM5o2i5oiQ5LiA5Liq77yM5L6/5LqO5LmL5ZCO55qE6K6h566XXG4gICAgICAgICAgICAgICAgYmVmb3JlID0gYmVmb3JlLnJlcGxhY2UoL1xcbiovLCAnXFxuJyk7XG5cbiAgICAgICAgICAgICAgICAvLyDmraPnoa7nmoTnvKnov5vlrZfnrKbkuLJcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkSW5kZW50U3RyID0gJyc7XG4gICAgICAgICAgICAgICAgLy8g5bGe5oCn5pe2IGluZGV4IOimgeWKoCAx77yM5Zug5Li66L+Z5LiqIGluZGV4IOaYryBydWxlIOeahCBpbmRleO+8jOiAjOWxnuaAp+WSjCBydWxlIOS5i+mXtOimgeacieS4gOS4que8qei/m1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGluZGV4ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZEluZGVudFN0ciArPSBpbmRlbnRTdHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYmVmb3JlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYWNrUHJlZml4Q2hhciA9IGJlZm9yZVtsZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFja1ByZWZpeENoYXIgPT09ICdfJyB8fCBoYWNrUHJlZml4Q2hhciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZEluZGVudFN0ciArPSBoYWNrUHJlZml4Q2hhcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlICE9PSAnXFxuJyArIHNob3VsZEluZGVudFN0cikge1xuICAgICAgICAgICAgICAgICAgICBhZGRXYXJuKGRlY2wsIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldE1zZyhiZWZvcmUucmVwbGFjZSgvXFxuL2csICcnKS5zbGljZSgwLCAtMSksIHNob3VsZEluZGVudFN0ci5zbGljZSgwLCAtMSkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiDlhbfkvZPnmoTmo4DmtYvpgLvovpFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyDlj4LmlbBcbiAqIEBwYXJhbSB7Kn0gb3B0cy5ydWxlVmFsIOW9k+WJjeinhOWImeWFt+S9k+mFjee9rueahOWAvFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmlsZUNvbnRlbnQg5paH5Lu25YaF5a65XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5maWxlUGF0aCDmlofku7bot6/lvoRcbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrID0gcG9zdGNzcy5wbHVnaW4oUlVMRU5BTUUsIG9wdHMgPT5cbiAgICAoY3NzLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdHMucnVsZVZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGluZUNhY2hlID0gMDtcblxuICAgICAgICAvLyDnvKnov5vnmoTlrZfnrKbkuLJcbiAgICAgICAgY29uc3QgaW5kZW50U3RyID0gb3B0cy5ydWxlVmFsWzBdO1xuXG4gICAgICAgIC8vIOW8gOWni+iuoeeul+e8qei/m+eahOWBj+enu+mHj++8jOebuOW9k+S6jui/meS4gOihjOeahCBjb2x1bW7vvIzlkowgb3B0cy5ydWxlVmFsWzBdIOayoeacieWFs+ezu1xuICAgICAgICBjb25zdCBzdGFydFBvcyA9IG9wdHMucnVsZVZhbFsxXTtcblxuICAgICAgICBjc3Mud2Fsa1J1bGVzKHJ1bGUgPT4ge1xuXG4gICAgICAgICAgICBpZiAoZ2xvYmFsLkNTU0hJTlRfSU5WQUxJRF9BTExfQ09VTlQgPj0gb3B0cy5tYXhFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g6L+Z6YeM55SoIGF0UnVsZUxpc3Qg5a+5IGF0UnVsZSDlgZrkuIDkuIvlpITnkIbmmK/lm6DkuLogcG9zdGNzcyDpu5jorqTmmK/ku44gZGVjbCAtPiBhdHJ1bGUgLT4gcnVsZSAtPiByb290XG4gICAgICAgICAgICAvLyDljbPku47ph4zlkJHlpJbnmoTpobrluo/lpITnkIbnmoTvvIzkvYbmmK/miJHku6zov5nph4zpnIDopoHnn6XpgZPnlLHph4zlkJHlpJbnmoTlsYLnuqfvvIzmiJHku6zpnIDopoHnn6XpgZPlsYLnuqfnmoTlvIDlp4vku6Xlj4rnu5PmnZ/ngrlcbiAgICAgICAgICAgIC8vIOWboOatpCBhdFJ1bGVMaXN0LnVuc2hpZnQg6L+Z5qC35YCS5bqP6L+H5p2lXG4gICAgICAgICAgICBjb25zdCBhdFJ1bGVMaXN0ID0gW107XG4gICAgICAgICAgICBsZXQgcGFyZW50UnVsZSA9IHJ1bGUucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudFJ1bGUudHlwZSA9PT0gJ2F0cnVsZScpIHtcbiAgICAgICAgICAgICAgICBhdFJ1bGVMaXN0LnVuc2hpZnQocGFyZW50UnVsZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50UnVsZSA9IHBhcmVudFJ1bGUucGFyZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdFJ1bGVMaXN0SXRlcmF0b3IoYXRSdWxlTGlzdCwgcmVzdWx0LCBydWxlLCBpbmRlbnRTdHIsIHN0YXJ0UG9zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuKTtcbiJdfQ==